## **–ü–∞—Ç—Ç–µ—Ä–Ω—ã –∑–∞–¥–∞—á —Å —Ö—ç—à-—Ç–∞–±–ª–∏—Ü–∞–º–∏ (HashMap / HashSet)**

---
## üéØ –¶–µ–ª–∏ –∑–∞–Ω—è—Ç–∏—è

–ö –∫–æ–Ω—Ü—É –∑–∞–Ω—è—Ç–∏—è —É—á–µ–Ω–∏–∫ –¥–æ–ª–∂–µ–Ω:

- —É–º–µ—Ç—å **—Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç—å –∑–∞–¥–∞—á–∏, –≥–¥–µ –Ω—É–∂–Ω–∞ —Ö—ç—à-—Ç–∞–±–ª–∏—Ü–∞**;
    
- –∑–Ω–∞—Ç—å **–∫–ª—é—á–µ–≤—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã** –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è hash map / set;
    
- –ø–æ–Ω–∏–º–∞—Ç—å, _—á—Ç–æ —Ö—Ä–∞–Ω–∏—Ç—å –≤ —Ö—ç—à–µ_ –∏ _–∑–∞—á–µ–º_;
    
- –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞—Ç—å —Ö—ç—à-—Ç–∞–±–ª–∏—Ü—ã —Å –¥—Ä—É–≥–∏–º–∏ —Ç–µ—Ö–Ω–∏–∫–∞–º–∏;
    
- —É–≤–µ—Ä–µ–Ω–Ω–æ —Ä–µ—à–∞—Ç—å —Ç–∏–ø–æ–≤—ã–µ –∑–∞–¥–∞—á–∏ —Å —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–π.
    

---

# ‚è± –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –∑–∞–Ω—è—Ç–∏—è

## 1Ô∏è‚É£ –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è –∑–∞–¥–∞—á –Ω–∞ —Ö—ç—à-—Ç–∞–±–ª–∏—Ü—ã (10 –º–∏–Ω—É—Ç)

### 1.1 –ö–∞–∫ –ø–æ–Ω—è—Ç—å, —á—Ç–æ –Ω—É–∂–Ω–∞ hash table

–î–∞—Ç—å —É—á–µ–Ω–∏–∫—É **—á–µ–∫-–ª–∏—Å—Ç**:

–•—ç—à-—Ç–∞–±–ª–∏—Ü–∞ –ø–æ—á—Ç–∏ –≤—Å–µ–≥–¥–∞ –Ω—É–∂–Ω–∞, –µ—Å–ª–∏:

- –Ω—É–∂–Ω–æ –±—ã—Å—Ç—Ä–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å ¬´–±—ã–ª–æ / –Ω–µ –±—ã–ª–æ¬ª;
    
- —Ç—Ä–µ–±—É–µ—Ç—Å—è –ø–æ–¥—Å—á—ë—Ç —á–∞—Å—Ç–æ—Ç;
    
- –Ω—É–∂–µ–Ω –±—ã—Å—Ç—Ä—ã–π –¥–æ—Å—Ç—É–ø –ø–æ –∫–ª—é—á—É;
    
- –Ω—É–∂–Ω–æ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å –¥–≤–∞ –Ω–∞–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö;
    
- –µ—Å—Ç—å —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è O(n) –ø–æ –≤—Ä–µ–º–µ–Ω–∏.
    

–§—Ä–∞–∑–∞-—è–∫–æ—Ä—å:

> ¬´–ù—É–∂–Ω–æ –±—ã—Å—Ç—Ä–æ –Ω–∞—Ö–æ–¥–∏—Ç—å / —Å—á–∏—Ç–∞—Ç—å / —Å–æ–ø–æ—Å—Ç–∞–≤–ª—è—Ç—å ‚Üí –¥—É–º–∞–π –ø—Ä–æ hash¬ª

---

### 1.2 –¢–∏–ø—ã –∑–∞–¥–∞—á

–†–∞–∑–¥–µ–ª–∏—Ç—å –∑–∞–¥–∞—á–∏ –Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏:

1. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–∞;
    
2. –ü–æ–¥—Å—á—ë—Ç —á–∞—Å—Ç–æ—Ç;
    
3. –°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π;
    
4. –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞;
    
5. –†–∞–±–æ—Ç–∞ —Å –æ–∫–Ω–∞–º–∏;
    
6. Prefix sum + hash;
    
7. Bucket-based –ø–æ–¥—Ö–æ–¥—ã.
    

---

## 2Ô∏è‚É£ –ü–∞—Ç—Ç–µ—Ä–Ω ‚Ññ1 ‚Äî Hash Set / Hash Map –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è (10 –º–∏–Ω—É—Ç)

### –ò–¥–µ—è

- —Ö—Ä–∞–Ω–∏—Ç—å —É–∂–µ —É–≤–∏–¥–µ–Ω–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã;
    
- –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –Ω–∞–ª–∏—á–∏–µ.
    

### –¢–∏–ø–æ–≤—ã–µ –∑–∞–¥–∞—á–∏

- –¥—É–±–ª–∏–∫–∞—Ç—ã;
    
- —Ü–∏–∫–ª—ã;
    
- –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –º–Ω–æ–∂–µ—Å—Ç–≤.
    

### –ü—Ä–∏–º–µ—Ä –∑–∞–¥–∞—á–∏ (–¥–µ–º–æ –æ—Ç –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è)

**LeetCode 217. Contains Duplicate**

–§–æ–∫—É—Å:

- set vs list;
    
- —Ä–∞–Ω–Ω–∏–π –≤—ã—Ö–æ–¥;
    
- –ø–∞–º—è—Ç—å vs —Å–∫–æ—Ä–æ—Å—Ç—å.
    
```

–î–∞–Ω —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ nums, –≤–µ—Ä–Ω–∏—Ç–µ true, –µ—Å–ª–∏ –∫–∞–∫–æ–µ-–ª–∏–±–æ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ—è–≤–ª—è–µ—Ç—Å—è –≤ –º–∞—Å—Å–∏–≤–µ –ø–æ –∫—Ä–∞–π–Ω–µ–π –º–µ—Ä–µ –¥–≤–∞–∂–¥—ã, –∏ –≤–µ—Ä–Ω–∏—Ç–µ false, –µ—Å–ª–∏ –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç —Ä–∞–∑–ª–∏—á–µ–Ω.

Example 1:
Input: nums = [1,2,3,1]
Output: true
Explanation:
The element 1 occurs at the indices 0 and 3.

Example 2:
Input: nums = [1,2,3,4]
Output: false
Explanation:
All elements are distinct.

Example 3:
Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true


```

```

from collections import Counter
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        
        # Count elements appearance
        for item in Counter(nums).items():
            if item[1] > 1:
                return True
            
        return False

```

---

## 3Ô∏è‚É£ –ü–∞—Ç—Ç–µ—Ä–Ω ‚Ññ2 ‚Äî –ü–æ–¥—Å—á—ë—Ç —á–∞—Å—Ç–æ—Ç (Frequency Map) (15 –º–∏–Ω—É—Ç)

### –ò–¥–µ—è

- –∫–ª—é—á ‚Üí –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ;
    
- –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è:
    
    - –∞–Ω–∞–≥—Ä–∞–º–º;
        
    - —Ç–æ–ø-K —ç–ª–µ–º–µ–Ω—Ç–æ–≤;
        
    - –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–∞ / —Ä–µ–¥–∫–æ—Å—Ç–∏.
        

### –ü—Ä–∏–º–µ—Ä –∑–∞–¥–∞—á–∏ (—Å–æ–≤–º–µ—Å—Ç–Ω–æ)

**LeetCode 242. Valid Anagram**

–†–∞–∑–æ–±—Ä–∞—Ç—å:

- –ø–æ—á–µ–º—É —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Ö—É–∂–µ;
    
- –ø–æ—á–µ–º—É hash map ‚Üí O(n).
    
```

–î–∞–Ω—ã –¥–≤–µ —Å—Ç—Ä–æ–∫–∏ s –∏ t, –≤–µ—Ä–Ω–∏—Ç–µ true, –µ—Å–ª–∏ t —è–≤–ª—è–µ—Ç—Å—è –∞–Ω–∞–≥—Ä–∞–º–º–æ–π s, –∏ false –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ.

Example 1:
Input: s = "anagram", t = "nagaram"
Output: true

Example 2:
Input: s = "rat", t = "car"
Output: false

```

```

from collections import defaultdict
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        
        # Count letters in each string
        cnt_s = defaultdict(int)
        for c in s:
            cnt_s[c] += 1
        
        cnt_t = defaultdict(int)
        for c in t:
            cnt_t[c] += 1
        
        # Check if they are equal
        return cnt_s == cnt_t
        

# Alternative
def isAnagram(self, s: str, t: str) -> bool:
	one = Counter(s)
	two = Counter(t)
	return one == two

```

---

## 4Ô∏è‚É£ –ü–∞—Ç—Ç–µ—Ä–Ω ‚Ññ3 ‚Äî Bucket Sort (15 –º–∏–Ω—É—Ç)

### –ò–¥–µ—è

- –∫–ª—é—á: —á–∞—Å—Ç–æ—Ç–∞;
    
- –∏–Ω–¥–µ–∫—Å = —á–∞—Å—Ç–æ—Ç–∞;
    
- –º–∞—Å—Å–∏–≤ –±–∞–∫–µ—Ç–æ–≤ + hash map.
    

### –ì–¥–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è

- Top K;
    
- —á–∞—Å—Ç–æ—Ç–Ω—ã–µ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏;
    
- –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω –∑–Ω–∞—á–µ–Ω–∏–π.
    

### –ü—Ä–∏–º–µ—Ä –∑–∞–¥–∞—á–∏ (–¥–µ–º–æ –æ—Ç –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è)

**LeetCode 347. Top K Frequent Elements**

–ü–æ–∫–∞–∑–∞—Ç—å:

- —á–∞—Å—Ç–æ—Ç–Ω—É—é –∫–∞—Ä—Ç—É;
    
- –º–∞—Å—Å–∏–≤ –±–∞–∫–µ—Ç–æ–≤;
    
- —Å–±–æ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞.
    

---

### –û–±—Å—É–∂–¥–µ–Ω–∏–µ

- –ø–æ—á–µ–º—É —ç—Ç–æ O(n);
    
- –ø–æ—á–µ–º—É –Ω–µ –Ω—É–∂–Ω–∞ –æ–±—ã—á–Ω–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞.
    

```

–î–∞–Ω —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ nums –∏ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ k, –≤–µ—Ä–Ω–∏—Ç–µ k –Ω–∞–∏–±–æ–ª–µ–µ —á–∞—Å—Ç–æ –≤—Å—Ç—Ä–µ—á–∞—é—â–∏—Ö—Å—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –í—ã –º–æ–∂–µ—Ç–µ –≤–µ—Ä–Ω—É—Ç—å –æ—Ç–≤–µ—Ç –≤ –ª—é–±–æ–º –ø–æ—Ä—è–¥–∫–µ.

Example 1:
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]

Example 2:
Input: nums = [1], k = 1
Output: [1]

Example 3:
Input: nums = [1,2,1,2,1,2,3,1,3,2], k = 2
Output: [1,2]

```

```

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        dct_cnt = {}
        for num in nums:
            dct_cnt[num] = dct_cnt.get(num, 0) + 1
        
        lst_cnt = [[] for _ in range(len(nums) + 1)]

        for num, cnt in dct_cnt.items():
            lst_cnt[cnt].append(num)

        res, count = [], k

        for cnt in range(len(lst_cnt) - 1, -1, -1):
            while lst_cnt[cnt] and count > 0:
                res.append(lst_cnt[cnt][-1])
                lst_cnt[cnt].pop()
                count -= 1

            if count == 0:
                return res

        return res

```

---

## 5Ô∏è‚É£ –ü–∞—Ç—Ç–µ—Ä–Ω ‚Ññ4 ‚Äî Sliding Window + Hash Map (20 –º–∏–Ω—É—Ç)

### –ò–¥–µ—è

- –æ–∫–Ω–æ + —Å—á—ë—Ç—á–∏–∫–∏;
    
- —Ä–∞—Å—à–∏—Ä—è–µ–º / —Å—É–∂–∞–µ–º –æ–∫–Ω–æ;
    
- hash map —Ö—Ä–∞–Ω–∏—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∫–Ω–∞.
    

---

### –¢–∏–ø–æ–≤—ã–µ –∑–∞–¥–∞—á–∏

- –ø–æ–¥—Å—Ç—Ä–æ–∫–∏;
    
- —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã;
    
- –æ–∫–Ω–∞ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º–∏.
    

---

### –ü—Ä–∏–º–µ—Ä –∑–∞–¥–∞—á–∏ (—Å–æ–≤–º–µ—Å—Ç–Ω–æ)

**LeetCode 3. Longest Substring Without Repeating Characters**

–§–æ–∫—É—Å:

- hash map: —Å–∏–º–≤–æ–ª ‚Üí –∏–Ω–¥–µ–∫—Å;
    
- —Å–¥–≤–∏–≥ –ª–µ–≤–æ–π –≥—Ä–∞–Ω–∏—Ü—ã;
    
- –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏–µ –∏–Ω–≤–∞—Ä–∏–∞–Ω—Ç–∞.
    

```

–î–∞–Ω–∞ —Å—Ç—Ä–æ–∫–∞ s, –Ω–∞–π–¥–∏—Ç–µ –¥–ª–∏–Ω—É —Å–∞–º–æ–π –¥–ª–∏–Ω–Ω–æ–π –ø–æ–¥—Å—Ç—Ä–æ–∫–∏ –±–µ–∑ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è —Å–∏–º–≤–æ–ª–æ–≤.

Example 1:
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3. Note that "bca" and "cab" are also correct answers.

Example 2:
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.

Example 3:
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.

```

```

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        cnt = set()
        max_len = 0

        left = 0
        for right in range(len(s)):
            while s[right] in cnt:
                cnt.remove(s[left])
                left += 1
            cnt.add(s[right])
            max_len = max(max_len, right - left + 1)

        return max_len

```

---

## 6Ô∏è‚É£ –ü–∞—Ç—Ç–µ—Ä–Ω ‚Ññ5 ‚Äî Prefix Sum + Hash Map (15 –º–∏–Ω—É—Ç)

### –ò–¥–µ—è

- —Ö—Ä–∞–Ω–∏—Ç—å —É–∂–µ –≤—Å—Ç—Ä–µ—á–µ–Ω–Ω—ã–µ –ø—Ä–µ—Ñ–∏–∫—Å–Ω—ã–µ —Å—É–º–º—ã;
    
- –±—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ –Ω—É–∂–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è.
    

---

### –¢–∏–ø–æ–≤—ã–µ –∑–∞–¥–∞—á–∏

- –ø–æ–¥–º–∞—Å—Å–∏–≤—ã;
    
- —Å—É–º–º—ã = k;
    
- –±–∞–ª–∞–Ω—Å—ã.
    

---

### –ü—Ä–∏–º–µ—Ä –∑–∞–¥–∞—á–∏ (–¥–µ–º–æ / —Å–æ–≤–º–µ—Å—Ç–Ω–æ)

**LeetCode 560. Subarray Sum Equals K**

–§–æ–∫—É—Å:

- –ø–æ—á–µ–º—É –¥–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è –Ω–µ —Ä–∞–±–æ—Ç–∞—é—Ç;
    
- —Ä–æ–ª—å `sum_count[0] = 1`.
    

---

## 7Ô∏è‚É£ –ü–∞—Ç—Ç–µ—Ä–Ω ‚Ññ6 ‚Äî Hash Map –∫–∞–∫ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ (Mapping) (5 –º–∏–Ω—É—Ç)

### –ò–¥–µ—è

- –∫–ª—é—á ‚Üí –∑–Ω–∞—á–µ–Ω–∏–µ;
    
- —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –¥–≤—É—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä.
    

### –ü—Ä–∏–º–µ—Ä –∑–∞–¥–∞—á–∏ (–±—ã—Å—Ç—Ä–æ)

**LeetCode 1. Two Sum**

–§–æ–∫—É—Å:

- –∏–Ω–¥–µ–∫—Å –∫–∞–∫ –∑–Ω–∞—á–µ–Ω–∏–µ;
    
- –æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥.
    

---

## 8Ô∏è‚É£ –ò—Ç–æ–≥–∏ –∏ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏ (10 –º–∏–Ω—É—Ç)

### –ò—Ç–æ–≥–∏ –∑–∞–Ω—è—Ç–∏—è

–£ —É—á–µ–Ω–∏–∫–∞ —Ç–µ–ø–µ—Ä—å –µ—Å—Ç—å:

- –∫–∞—Ä—Ç–∞ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤;
    
- –ø–æ–Ω–∏–º–∞–Ω–∏–µ _–≥–¥–µ –∏ –∑–∞—á–µ–º_ –Ω—É–∂–µ–Ω hash map;
    
- –æ–ø—ã—Ç –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Å –¥—Ä—É–≥–∏–º–∏ —Ç–µ—Ö–Ω–∏–∫–∞–º–∏.
    

---

## üè† –î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ (–∏–∑ —Ä–∞–∑–æ–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤)

- [217](https://leetcode.com/problems/contains-duplicate/description/)
- [268](https://leetcode.com/problems/missing-number/description/)
- [36](https://leetcode.com/problems/valid-sudoku/description/)
- [242](https://leetcode.com/problems/valid-anagram/description/)
- [383](https://leetcode.com/problems/ransom-note/description/)
- [169](https://leetcode.com/problems/majority-element/description/)
- [347](https://leetcode.com/problems/top-k-frequent-elements/)
- [451](https://leetcode.com/problems/sort-characters-by-frequency/description/)
- [1](https://leetcode.com/problems/two-sum/description/)

–ó–∞–ø–∏—Å–∏ —Å –∑–∞–Ω—è—Ç–∏—è

```


# –ó–∞–¥–∞—á–∞ 217

# –î–∞–Ω —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ nums, –≤–µ—Ä–Ω–∏—Ç–µ true, –µ—Å–ª–∏ –∫–∞–∫–æ–µ-–ª–∏–±–æ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ—è–≤–ª—è–µ—Ç—Å—è –≤ –º–∞—Å—Å–∏–≤–µ –ø–æ –∫—Ä–∞–π–Ω–µ–π –º–µ—Ä–µ –¥–≤–∞–∂–¥—ã, –∏ –≤–µ—Ä–Ω–∏—Ç–µ false, –µ—Å–ª–∏ –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç —Ä–∞–∑–ª–∏—á–µ–Ω.

# Example 1:
# Input: nums = [1,2,3,1]
# Output: true
# Explanation:
# The element 1 occurs at the indices 0 and 3.

# Example 2:
# Input: nums = [1,2,3,4]
# Output: false
# Explanation:
# All elements are distinct.

# Example 3:
# Input: nums = [1,1,1,3,3,4,3,2,4,2]
# Output: true


def containsDuplicate(nums: list[int]) -> bool:
  return len(nums) != len(set(nums))

# 242

# –î–∞–Ω—ã –¥–≤–µ —Å—Ç—Ä–æ–∫–∏ s –∏ t, –≤–µ—Ä–Ω–∏—Ç–µ true, –µ—Å–ª–∏ t —è–≤–ª—è–µ—Ç—Å—è –∞–Ω–∞–≥—Ä–∞–º–º–æ–π s, –∏ false –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ.

# Example 1:
# Input: s = "anagram", t = "nagaram"
# Output: true

# Example 2:
# Input: s = "rat", t = "car"
# Output: false
def isAnagram(s: str, t: str) -> bool:
  c = dict()
  for el in s:
    if el in c:
      c[el] += 1
    else:
      c[el] = 1
  c1 = dict()
  for el in t:
    if el in t:
      c1[el] += 1
    else:
      c1[el] = 1
  return c == c1



from collections import Counter
def isAnagram(s: str, t: str) -> bool:
  return Counter(s) == Counter(t)



# –î–∞–Ω —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ nums –∏ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ k, –≤–µ—Ä–Ω–∏—Ç–µ k –Ω–∞–∏–±–æ–ª–µ–µ —á–∞—Å—Ç–æ –≤—Å—Ç—Ä–µ—á–∞—é—â–∏—Ö—Å—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –í—ã –º–æ–∂–µ—Ç–µ –≤–µ—Ä–Ω—É—Ç—å –æ—Ç–≤–µ—Ç –≤ –ª—é–±–æ–º –ø–æ—Ä—è–¥–∫–µ.

# Example 1:
# Input: nums = [1,1,1,2,2,3], k = 2
# Output: [1,2]

# Example 2:
# Input: nums = [1], k = 1
# Output: [1]

# Example 3:
# Input: nums = [1,2,1,2,1,2,3,1,3,2], k = 2
# Output: [1,2]
c = dict()
1 - 5
[0,1,2,3,4,5,6,7,8,9]



```