
## **Ğ”Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ 2D (DP 2D)**
---

# ğŸ¯ Ğ¦ĞµĞ»Ğ¸ Ğ·Ğ°Ğ½ÑÑ‚Ğ¸Ñ

Ğš ĞºĞ¾Ğ½Ñ†Ñƒ Ğ·Ğ°Ğ½ÑÑ‚Ğ¸Ñ ÑƒÑ‡ĞµĞ½Ğ¸Ğº Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½:

- Ğ¿Ğ¾Ğ½Ğ¸Ğ¼Ğ°Ñ‚ÑŒ, **Ñ‡ĞµĞ¼ 2D DP Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ°ĞµÑ‚ÑÑ Ğ¾Ñ‚ 1D DP**;
    
- ÑƒĞ¼ĞµÑ‚ÑŒ Ñ€Ğ°ÑĞ¿Ğ¾Ğ·Ğ½Ğ°Ğ²Ğ°Ñ‚ÑŒ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸, Ğ³Ğ´Ğµ 1D ÑƒĞ¶Ğµ Ğ½ĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾;
    
- ÑƒĞ¼ĞµÑ‚ÑŒ Ñ„Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ:
    
    - ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ `dp[i][j]`,
        
    - Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´,
        
    - Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ ÑĞ»ÑƒÑ‡Ğ°Ğ¸;
        
- Ğ¿Ğ¾Ğ½Ğ¸Ğ¼Ğ°Ñ‚ÑŒ Ñ‚Ğ¸Ğ¿Ğ¾Ğ²Ñ‹Ğµ Ñ„Ğ¾Ñ€Ğ¼Ñ‹ 2D DP:
    
    - Ğ¿Ğ¾ Ğ¼Ğ°Ñ‚Ñ€Ğ¸Ñ†Ğµ,
        
    - Ğ¿Ğ¾ Ğ´Ğ²ÑƒĞ¼ ÑÑ‚Ñ€Ğ¾ĞºĞ°Ğ¼,
        
    - â€œĞ²Ñ‹Ğ±Ğ¾Ñ€ / Ğ½Ğµ Ğ²Ñ‹Ğ±Ğ¾Ñ€â€ Ñ Ğ´Ğ²ÑƒĞ¼Ñ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ°Ğ¼Ğ¸;
        
- Ñ€ĞµÑˆĞ¸Ñ‚ÑŒ 3â€“4 ĞºĞ»Ğ°ÑÑĞ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸.
    

---

# â± Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ·Ğ°Ğ½ÑÑ‚Ğ¸Ñ

---

## 1ï¸âƒ£ ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€ 1D DP + Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´ Ğº 2D (10 Ğ¼Ğ¸Ğ½ÑƒÑ‚)

### Ğ‘Ñ‹ÑÑ‚Ñ€Ğ¾Ğµ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ĞµĞ½Ğ¸Ğµ:

Ğ¡Ğ¿Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ ÑƒÑ‡ĞµĞ½Ğ¸ĞºĞ°:

- Ñ‡Ñ‚Ğ¾ Ñ‚Ğ°ĞºĞ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ?
    
- ĞºĞ°Ğº ÑÑ‚Ñ€Ğ¾Ğ¸Ñ‚ÑÑ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´?
    
- ĞºĞ°Ğº Ğ¿Ğ¾Ğ½ÑÑ‚ÑŒ, Ñ‡Ñ‚Ğ¾ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ° â€” DP?
    

Ğ—Ğ°Ñ„Ğ¸ĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ:

> Ğ’ 1D DP ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ° â€” Ñ‡Ğ°Ñ‰Ğµ Ğ²ÑĞµĞ³Ğ¾ Ğ¸Ğ½Ğ´ĞµĞºÑĞ°.

---

### ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´ Ğº 2D

ĞšĞ¾Ğ³Ğ´Ğ° 1D Ğ½ĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾?

ĞŸÑ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ¸:

- Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ **Ğ¾Ñ‚ Ğ´Ğ²ÑƒÑ… Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ²**;
    
- ĞµÑÑ‚ÑŒ **Ğ´Ğ²Ğ° Ğ¸Ğ·Ğ¼ĞµÑ€ĞµĞ½Ğ¸Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…** (ÑÑ‚Ñ€Ğ¾ĞºĞ° + ÑÑ‚Ñ€Ğ¾ĞºĞ°, Ğ¼Ğ°Ñ‚Ñ€Ğ¸Ñ†Ğ°);
    
- Ğ²Ğ°Ğ¶Ğ½Ñ‹ Ğ¸ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ, Ğ¸ ĞµÑ‰Ñ‘ ĞºĞ°ĞºĞ¾Ğµ-Ñ‚Ğ¾ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾ÑÑ‚Ğ°Ğ²ÑˆĞ¸Ñ…ÑÑ ÑˆĞ°Ğ³Ğ¾Ğ²).
    

Ğ¤Ñ€Ğ°Ğ·Ğ°-ÑĞºĞ¾Ñ€ÑŒ:

> Ğ•ÑĞ»Ğ¸ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ¸Ğ½Ğ´ĞµĞºÑĞ° Ğ¼Ğ°Ğ»Ğ¾, Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ¼Ğ½Ğ¸Ñ‚ÑŒ ĞµÑ‰Ñ‘ Ñ‡Ñ‚Ğ¾-Ñ‚Ğ¾ â€” ÑÑ‚Ğ¾ ĞºĞ°Ğ½Ğ´Ğ¸Ğ´Ğ°Ñ‚ Ğ½Ğ° 2D DP.

---

## 2ï¸âƒ£ Ğ¢ĞµĞ¾Ñ€Ğ¸Ñ: ĞºĞ°Ğº ÑÑ‚Ñ€Ğ¾Ğ¸Ñ‚ÑŒ 2D DP (20 Ğ¼Ğ¸Ğ½ÑƒÑ‚)

---

### 2.1 Ğ§Ñ‚Ğ¾ Ñ‚Ğ°ĞºĞ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ `dp[i][j]`

ĞĞ±ÑŠÑÑĞ½Ğ¸Ñ‚ÑŒ:

`dp[i][j]` â€” ÑÑ‚Ğ¾ Ğ¾Ñ‚Ğ²ĞµÑ‚ Ğ´Ğ»Ñ:

- Ğ¿ĞµÑ€Ğ²Ñ‹Ñ… `i` ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ² Ğ¿ĞµÑ€Ğ²Ğ¾Ğ¹ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹,
    
- Ğ¿ĞµÑ€Ğ²Ñ‹Ñ… `j` ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ² Ğ²Ñ‚Ğ¾Ñ€Ğ¾Ğ¹ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹.
    

Ğ˜Ğ»Ğ¸:

- ĞºĞ»ĞµÑ‚ĞºĞ¸ `(i, j)` Ğ² Ğ¼Ğ°Ñ‚Ñ€Ğ¸Ñ†Ğµ,
    
- Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ `i` Ğ¸ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ñ `j`.
    

Ğ’Ğ°Ğ¶Ğ½Ğ¾:

> Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°Ñ‚ÑŒ Ğ½Ğ° ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ğ¹, Ñ‡Ñ‘Ñ‚ĞºĞ¸Ğ¹ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ.

---

### 2.2 Ğ¢Ğ¸Ğ¿Ğ¾Ğ²Ñ‹Ğµ Ñ„Ğ¾Ñ€Ğ¼Ñ‹ 2D DP

#### ğŸ“Œ Ğ¢Ğ¸Ğ¿ 1 â€” DP Ğ¿Ğ¾ ÑĞµÑ‚ĞºĞµ (Grid DP)

- Ğ´Ğ²Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ Ğ¼Ğ°Ñ‚Ñ€Ğ¸Ñ†Ğµ
    
- Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸: ÑĞ²ĞµÑ€Ñ…Ñƒ, ÑĞ»ĞµĞ²Ğ°
    

#### ğŸ“Œ Ğ¢Ğ¸Ğ¿ 2 â€” DP Ğ¿Ğ¾ Ğ´Ğ²ÑƒĞ¼ ÑÑ‚Ñ€Ğ¾ĞºĞ°Ğ¼

- ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğµ ÑÑ‚Ñ€Ğ¾Ğº
    
- LCS-Ğ¿Ğ¾Ğ´Ğ¾Ğ±Ğ½Ñ‹Ğµ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸
    

#### ğŸ“Œ Ğ¢Ğ¸Ğ¿ 3 â€” DP Ñ Ğ´Ğ²ÑƒĞ¼Ñ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ°Ğ¼Ğ¸ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ°

- Ğ¸Ğ½Ğ´ĞµĞºÑ + Ñ€ĞµÑÑƒÑ€Ñ
    
- Ğ¸Ğ½Ğ´ĞµĞºÑ + ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹
    

---

### 2.3 ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´

ĞĞ±ÑŠÑÑĞ½Ğ¸Ñ‚ÑŒ ÑƒĞ½Ğ¸Ğ²ĞµÑ€ÑĞ°Ğ»ÑŒĞ½Ğ¾:

`dp[i][j]` = Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ¾Ñ‚:

- `dp[i-1][j]`
    
- `dp[i][j-1]`
    
- `dp[i-1][j-1]`
    
- Ğ¸ Ñ‚.Ğ´.
    

Ğ¤Ñ€Ğ°Ğ·Ğ°-ÑĞºĞ¾Ñ€ÑŒ:

> Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ½ÑÑ‚ÑŒ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´, ÑĞ¿Ñ€Ğ¾ÑĞ¸: Â«Ğ˜Ğ· ĞºĞ°ĞºĞ¸Ñ… ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğ¹ Ñ Ğ¼Ğ¾Ğ³ Ğ¿Ñ€Ğ¸Ğ¹Ñ‚Ğ¸ ÑÑĞ´Ğ°?Â»

---

### 2.4 Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ ÑĞ»ÑƒÑ‡Ğ°Ğ¸

ĞÑ‡ĞµĞ½ÑŒ Ğ²Ğ°Ğ¶Ğ½Ğ¾:

- Ğ¿ĞµÑ€Ğ²Ğ°Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ°
    
- Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ ÑÑ‚Ğ¾Ğ»Ğ±ĞµÑ†
    
- `dp[0][0]`
    

Ğ‘Ğ¾Ğ»ÑŒÑˆĞ¸Ğ½ÑÑ‚Ğ²Ğ¾ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº â€” Ğ¸Ğ¼ĞµĞ½Ğ½Ğ¾ Ğ·Ğ´ĞµÑÑŒ.

---

### 2.5 ĞšĞ¾Ğ³Ğ´Ğ° 2D DP ĞĞ• Ğ½ÑƒĞ¶Ğ½Ğ¾

ĞŸÑ€Ğ¾Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ¸Ñ‚ÑŒ:

2D DP Ğ½Ğµ Ğ½ÑƒĞ¶ĞµĞ½, ĞµÑĞ»Ğ¸:

- ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ ÑƒĞ¿Ñ€Ğ¾ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ´Ğ¾ 1D;
    
- Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ° Ñ€ĞµÑˆĞ°ĞµÑ‚ÑÑ greedy;
    
- Ğ½ĞµÑ‚ Ğ¿ĞµÑ€ĞµĞºÑ€Ñ‹Ğ²Ğ°ÑÑ‰Ğ¸Ñ…ÑÑ Ğ¿Ğ¾Ğ´Ğ·Ğ°Ğ´Ğ°Ñ‡;
    
- Ğ¿Ñ€Ğ¾ÑÑ‚Ñ€Ğ°Ğ½ÑÑ‚Ğ²Ğ¾ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğ¹ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğµ.
    

---

# 3ï¸âƒ£ ĞŸÑ€Ğ°ĞºÑ‚Ğ¸ĞºĞ° (55â€“60 Ğ¼Ğ¸Ğ½ÑƒÑ‚)

---

## ğŸ§© Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ° 1 â€” Ğ´ĞµĞ¼Ğ¾Ğ½ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ

### ğŸ”¹ LeetCode 62 â€” Unique Paths (10â€“15 Ğ¼Ğ¸Ğ½)

Ğ¢Ğ¸Ğ¿: Grid DP

Ğ˜Ğ´ĞµÑ:

- `dp[i][j]` â€” ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¿ÑƒÑ‚ĞµĞ¹ Ğ´Ğ¾ ĞºĞ»ĞµÑ‚ĞºĞ¸
    
- Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´: ÑĞ²ĞµÑ€Ñ…Ñƒ + ÑĞ»ĞµĞ²Ğ°
    

Ğ¤Ğ¾ĞºÑƒÑ:

- Ğ°ĞºĞºÑƒÑ€Ğ°Ñ‚Ğ½Ğ°Ñ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ Ğ¸ ÑÑ‚Ğ¾Ğ»Ğ±Ñ†Ğ°
    
- Ğ¾Ğ±ÑŠÑÑĞ½ĞµĞ½Ğ¸Ğµ, Ğ¿Ğ¾Ñ‡ĞµĞ¼Ñƒ ÑÑ‚Ğ¾ 2D DP
    

```

ĞĞ° ÑĞµÑ‚ĞºĞµ m x n ĞµÑÑ‚ÑŒ Ñ€Ğ¾Ğ±Ğ¾Ñ‚. Ğ˜Ğ·Ğ½Ğ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ¾ Ñ€Ğ¾Ğ±Ğ¾Ñ‚ Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑÑ Ğ² Ğ²ĞµÑ€Ñ…Ğ½ĞµĞ¼ Ğ»ĞµĞ²Ğ¾Ğ¼ ÑƒĞ³Ğ»Ñƒ (Ñ‚.Ğµ. Ğ² ÑĞµÑ‚ĞºĞµ[0][0]). Ğ Ğ¾Ğ±Ğ¾Ñ‚ Ğ¿Ñ‹Ñ‚Ğ°ĞµÑ‚ÑÑ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒÑÑ Ğ² Ğ¿Ñ€Ğ°Ğ²Ñ‹Ğ¹ Ğ½Ğ¸Ğ¶Ğ½Ğ¸Ğ¹ ÑƒĞ³Ğ¾Ğ» (Ñ‚.Ğµ. Ğ² ÑĞµÑ‚ĞºÑƒ[m - 1][n - 1]). Ğ’ Ğ»ÑĞ±Ğ¾Ğ¹ Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸ Ñ€Ğ¾Ğ±Ğ¾Ñ‚ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰Ğ°Ñ‚ÑŒÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ²Ğ½Ğ¸Ğ· Ğ¸Ğ»Ğ¸ Ğ²Ğ¿Ñ€Ğ°Ğ²Ğ¾.

Ğ£Ñ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°Ñ Ğ´Ğ²Ğ° Ñ†ĞµĞ»Ñ‹Ñ… Ñ‡Ğ¸ÑĞ»Ğ° m Ğ¸ n, Ğ²ĞµÑ€Ğ½Ğ¸Ñ‚Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ñ‹Ñ… ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ¿ÑƒÑ‚ĞµĞ¹, Ğ¿Ğ¾ ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¼ Ñ€Ğ¾Ğ±Ğ¾Ñ‚ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ñ€Ğ¾Ğ¹Ñ‚Ğ¸, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ´Ğ¾ÑÑ‚Ğ¸Ñ‡ÑŒ Ğ½Ğ¸Ğ¶Ğ½ĞµĞ³Ğ¾ Ğ¿Ñ€Ğ°Ğ²Ğ¾Ğ³Ğ¾ ÑƒĞ³Ğ»Ğ°.

Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¸Ñ Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒÑÑ‚ÑÑ Ñ‚Ğ°ĞºĞ¸Ğ¼ Ğ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ¼, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¾Ñ‚Ğ²ĞµÑ‚ Ğ±Ñ‹Ğ» Ğ¼ĞµĞ½ÑŒÑˆĞµ Ğ¸Ğ»Ğ¸ Ñ€Ğ°Ğ²ĞµĞ½ 2 * 109.

Example 1:
Input: m = 3, n = 7
Output: 28

Example 2:
Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down

```

```
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        
        # Initialize DP arr: dp[i][j] - amount of routes robot can get to cell (i,j)
        dp = [[1 for i in range(n)] for j in range(m)]
        
        # Iterate through each cell (except firs row and first col - only 1 route)
        for i in range(1,m):
            for j in range(1,n):
                # Amount of routes to get in current cell
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        
        # Return amount of routes we can get to the last cell of the board
        return dp[-1][-1]

class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [0] * n
        dp[0] = 1
        
        for i in range(m):
            for j in range(n):
                dp[j] = dp[j] + (dp[j-1] if j-1 >= 0 else 0)
                
        return dp[-1]


```

---

## ğŸ§© Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ° 2 â€” ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ½Ğ¾

### ğŸ”¹ LeetCode 64 â€” Minimum Path Sum (15 Ğ¼Ğ¸Ğ½)

Ğ¢Ğ¸Ğ¿: Grid DP (Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ)

Ğ¤Ğ¾ĞºÑƒÑ:

- Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ğ¾Ñ‚ Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰ĞµĞ¹ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸
    
- Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´ Ñ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼Ğ¾Ğ¼
    
- Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ Ğ²Ñ…Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ğ¼Ğ°Ñ‚Ñ€Ğ¸Ñ†ĞµĞ¹
    

ĞĞ±ÑÑƒĞ´Ğ¸Ñ‚ÑŒ:

- Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ»Ğ¸ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ Ğ´Ğ¾ 1D?
    
```

Ğ—Ğ°Ğ´Ğ°Ğ½Ğ° ÑĞµÑ‚ĞºĞ° m x n, Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ğ°Ñ Ğ½ĞµĞ¾Ñ‚Ñ€Ğ¸Ñ†Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ Ñ‡Ğ¸ÑĞ»Ğ°Ğ¼Ğ¸, Ğ½Ğ°Ğ¹Ğ´Ğ¸Ñ‚Ğµ Ğ¿ÑƒÑ‚ÑŒ Ğ¸Ğ· Ğ²ĞµÑ€Ñ…Ğ½ĞµĞ³Ğ¾ Ğ»ĞµĞ²Ğ¾Ğ³Ğ¾ ÑƒĞ³Ğ»Ğ° Ğ² Ğ½Ğ¸Ğ¶Ğ½Ğ¸Ğ¹ Ğ¿Ñ€Ğ°Ğ²Ñ‹Ğ¹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµÑ‚ ÑÑƒĞ¼Ğ¼Ñƒ Ğ²ÑĞµÑ… Ñ‡Ğ¸ÑĞµĞ» Ğ½Ğ° ÑÑ‚Ğ¾Ğ¼ Ğ¿ÑƒÑ‚Ğ¸.

ĞŸÑ€Ğ¸Ğ¼ĞµÑ‡Ğ°Ğ½Ğ¸Ğµ: Ğ’ Ğ»ÑĞ±Ğ¾Ğ¹ Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸ Ğ²Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰Ğ°Ñ‚ÑŒÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ²Ğ½Ğ¸Ğ· Ğ¸Ğ»Ğ¸ Ğ²Ğ¿Ñ€Ğ°Ğ²Ğ¾.

Example 1:
Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1 â†’ 3 â†’ 1 â†’ 1 â†’ 1 minimizes the sum.

Example 2:
Input: grid = [[1,2,3],[4,5,6]]
Output: 12
 

```

```

class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
            
        
        m, n = len(grid), len(grid[0])
        
        for i in range(1, m):
            grid[i][0] += grid[i-1][0]
        
        for i in range(1, n):
            grid[0][i] += grid[0][i-1]
        
        for i in range(1, m):
            for j in range(1, n):
                grid[i][j] += min(grid[i-1][j], grid[i][j-1])
        
        return grid[-1][-1]
    
        # An Upvote will be encouraging

public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        for(int i=1;i<n;i++){
            grid[0][i] += grid[0][i-1];
        }
        for(int i=1;i<m;i++){
            grid[i][0] += grid[i-1][0];
        }
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);
            }
        }
        return grid[m-1][n-1];
    }

```

---

## ğŸ§© Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ° 3 â€” ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ½Ğ¾ / ÑƒÑ‡ĞµĞ½Ğ¸Ğº

### ğŸ”¹ LeetCode 1143 â€” Longest Common Subsequence (20 Ğ¼Ğ¸Ğ½)

Ğ¢Ğ¸Ğ¿: DP Ğ¿Ğ¾ Ğ´Ğ²ÑƒĞ¼ ÑÑ‚Ñ€Ğ¾ĞºĞ°Ğ¼

Ğ­Ñ‚Ğ¾ ĞºĞ»ÑÑ‡ĞµĞ²Ğ°Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ° Ğ·Ğ°Ğ½ÑÑ‚Ğ¸Ñ.

Ğ¤Ğ¾ĞºÑƒÑ:

- `dp[i][j]` â€” LCS Ğ´Ğ»Ñ Ğ¿ĞµÑ€Ğ²Ñ‹Ñ… i Ğ¸ j ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²
    
- ĞµÑĞ»Ğ¸ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ‹ Ñ€Ğ°Ğ²Ğ½Ñ‹ â†’ +1
    
- Ğ¸Ğ½Ğ°Ñ‡Ğµ â†’ max ÑĞ»ĞµĞ²Ğ° Ğ¸ ÑĞ²ĞµÑ€Ñ…Ñƒ
    

ĞÑ‡ĞµĞ½ÑŒ Ğ²Ğ°Ğ¶Ğ½Ğ¾:

- Ğ°ĞºĞºÑƒÑ€Ğ°Ñ‚Ğ½Ğ¾ Ñ€Ğ°Ğ·Ğ¾Ğ±Ñ€Ğ°Ñ‚ÑŒ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ Ğ½Ğ° Ğ´Ğ¾ÑĞºĞµ
    
- Ğ¿Ñ€Ğ¾Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ¸Ñ‚ÑŒ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´ ÑĞ»Ğ¾Ğ²Ğ°Ğ¼Ğ¸
    

```

Ğ”Ğ»Ñ Ğ´Ğ²ÑƒÑ… ÑÑ‚Ñ€Ğ¾Ğº text1 Ğ¸ text2 Ğ²ĞµÑ€Ğ½Ğ¸Ñ‚Ğµ Ğ´Ğ»Ğ¸Ğ½Ñƒ Ğ¸Ñ… ÑĞ°Ğ¼Ğ¾Ğ¹ Ğ´Ğ»Ğ¸Ğ½Ğ½Ğ¾Ğ¹ Ğ¾Ğ±Ñ‰ĞµĞ¹ Ğ¿Ğ¾Ğ´Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸. Ğ•ÑĞ»Ğ¸ Ğ¾Ğ±Ñ‰ĞµĞ¹ Ğ¿Ğ¾Ğ´Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ Ğ½ĞµÑ‚, Ğ²ĞµÑ€Ğ½Ğ¸Ñ‚Ğµ 0.

ĞŸĞ¾Ğ´Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ - ÑÑ‚Ğ¾ Ğ½Ğ¾Ğ²Ğ°Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ°, ÑĞ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ğ¸Ğ· Ğ¸ÑÑ…Ğ¾Ğ´Ğ½Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ Ñ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸ĞµĞ¼ Ğ½ĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ² (Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ, Ğ½Ğ¸ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾) Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ¾Ñ‚Ğ½Ğ¾ÑĞ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞ° Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ².

ĞĞ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, "ace" ÑĞ²Ğ»ÑĞµÑ‚ÑÑ Ğ¿Ğ¾Ğ´Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒÑ "abcde".
ĞĞ±Ñ‰Ğ°Ñ Ğ¿Ğ¾Ğ´Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ğ´Ğ²ÑƒÑ… ÑÑ‚Ñ€Ğ¾Ğº - ÑÑ‚Ğ¾ Ğ¿Ğ¾Ğ´Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ°Ñ ÑĞ²Ğ»ÑĞµÑ‚ÑÑ Ğ¾Ğ±Ñ‰ĞµĞ¹ Ğ´Ğ»Ñ Ğ¾Ğ±ĞµĞ¸Ñ… ÑÑ‚Ñ€Ğ¾Ğº.

Example 1:
Input: text1 = "abcde", text2 = "ace" 
Output: 3  
Explanation: The longest common subsequence is "ace" and its length is 3.

Example 2:
Input: text1 = "abc", text2 = "abc"
Output: 3
Explanation: The longest common subsequence is "abc" and its length is 3.

Example 3:
Input: text1 = "abc", text2 = "def"
Output: 0
Explanation: There is no such common subsequence, so the result is 0.

```

```


class Solution:
	def longestCommonSubsequence(self, s1: str, s2: str) -> int:
		m = len(s1)
		n = len(s2)
		memo = [[0 for _ in range(n + 1)] for _ in range(m + 1)]

		for row in range(1, m + 1):
			for col in range(1, n + 1):
				if s1[row - 1] == s2[col - 1]:
					memo[row][col] = 1 + memo[row - 1][col - 1]
				else:
					memo[row][col] = max(memo[row][col - 1], memo[row - 1][col])

		return memo[m][n]

```


---

## ğŸ§© (ĞĞ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾, ĞµÑĞ»Ğ¸ Ğ¾ÑÑ‚Ğ°Ñ‘Ñ‚ÑÑ Ğ²Ñ€ĞµĞ¼Ñ)

### ğŸ”¹ LeetCode 72 â€” Edit Distance

Ğ Ğ°Ğ·Ğ¾Ğ±Ñ€Ğ°Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¸Ğ´ĞµÑ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ¸ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ° (Ğ±ĞµĞ· Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ´Ğ°).

```

Ğ£Ñ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°Ñ Ğ´Ğ²Ğµ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ word1 Ğ¸ word2, Ğ²ĞµÑ€Ğ½Ğ¸Ñ‚Ğµ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹, Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ñ‹Ñ… Ğ´Ğ»Ñ Ğ¿Ñ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ word1 Ğ² word2.

Ğ”Ğ»Ñ ÑĞ»Ğ¾Ğ²Ğ° Ğ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ñ‹ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğµ Ñ‚Ñ€Ğ¸ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸:

Ğ’ÑÑ‚Ğ°Ğ²ĞºĞ° ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°
Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°
Ğ—Ğ°Ğ¼ĞµĞ½Ğ° ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°

Example 1:
Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')

Example 2:
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')



```

```

# How is Matrix built :

- The matrix is built iteratively using the following recurrence relation:

1. IfÂ `word1[i-1] == word2[j-1]`, thenÂ `dp[i][j] = dp[i-1][j-1]`. That is, no operation is required because the characters at positionsÂ `i-1`Â andÂ `j-1`Â are already the same.
2. Otherwise,Â `dp[i][j]`Â is the minimum of the following three values:

- `dp[i-1][j-1] + 1`: replace the character at positionÂ `i-1`Â inÂ `word1`Â with the character at positionÂ `j-1`Â inÂ `word2`.
- `dp[i-1][j] + 1`: delete the character at positionÂ `i-1`Â inÂ `word1.`
- `dp[i][j-1] + 1`: insert the character at positionÂ `j-1`Â inÂ `word2`Â intoÂ `word1`Â at positionÂ `i`.

# The base cases are:

- `dp[i][0] = i`: transformingÂ `word1[0...i-1]`Â into an empty string requiresÂ `i`Â deletions.
- `dp[0][j] = j`: transforming an empty string intoÂ `word2[0...j-1]`Â requiresÂ `j`Â insertions.

# Final Step :

- Finally, returnÂ `dp[m][n]`, which represents the minimum number of operations required to transformÂ `word1`Â intoÂ `word2`, whereÂ `m`Â is the length ofÂ `word1`Â andÂ `n`Â is the length ofÂ `word2`.

---

class Solution:
    def minDistance(self, word1, word2):
        """Dynamic programming solution"""
        m = len(word1)
        n = len(word2)
        table = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(m + 1):
            table[i][0] = i
        for j in range(n + 1):
            table[0][j] = j

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if word1[i - 1] == word2[j - 1]:
                    table[i][j] = table[i - 1][j - 1]
                else:
                    table[i][j] = 1 + min(table[i - 1][j], table[i][j - 1], table[i - 1][j - 1])
        return table[-1][-1]

```

---

# 4ï¸âƒ£ Ğ¡Ñ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğµ 1D Ğ¸ 2D DP (5â€“10 Ğ¼Ğ¸Ğ½ÑƒÑ‚)

Ğ¡Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ Ğ¼Ğ¸Ğ½Ğ¸-Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ:

|1D DP|2D DP|
|---|---|
|ĞĞ´Ğ¸Ğ½ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€|Ğ”Ğ²Ğ° Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ°|
|Ğ§Ğ°Ñ‰Ğµ Ğ¿Ğ¾ Ğ¼Ğ°ÑÑĞ¸Ğ²Ñƒ|Ğ§Ğ°ÑÑ‚Ğ¾ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ / Ğ¼Ğ°Ñ‚Ñ€Ğ¸Ñ†Ñ‹|
|ĞŸÑ€Ğ¾ÑÑ‚Ñ‹Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸|Ğ‘Ğ¾Ğ»ĞµĞµ ÑĞ»Ğ¾Ğ¶Ğ½Ñ‹Ğµ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ñ‹|
|Ğ§Ğ°ÑÑ‚Ğ¾ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ¾ O(1) Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸|Ğ˜Ğ½Ğ¾Ğ³Ğ´Ğ° Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ ÑĞ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ² 1D|

---

# 5ï¸âƒ£ Ğ˜Ñ‚Ğ¾Ğ³Ğ¸ Ğ·Ğ°Ğ½ÑÑ‚Ğ¸Ñ (5 Ğ¼Ğ¸Ğ½ÑƒÑ‚)

Ğ£Ñ‡ĞµĞ½Ğ¸Ğº Ñ‚ĞµĞ¿ĞµÑ€ÑŒ:

- Ğ¿Ğ¾Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚, ĞºĞ¾Ğ³Ğ´Ğ° 1D ÑƒĞ¶Ğµ Ğ½ĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾;
    
- ÑƒĞ¼ĞµĞµÑ‚ Ñ„Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ `dp[i][j]`;
    
- Ğ½Ğµ Ğ¿ÑƒÑ‚Ğ°ĞµÑ‚ÑÑ Ğ² Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ°Ñ…;
    
- Ğ·Ğ½Ğ°ĞµÑ‚ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ ÑˆĞ°Ğ±Ğ»Ğ¾Ğ½Ñ‹ 2D DP;
    
- Ğ¿Ğ¾Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚, ĞºĞ°Ğº Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ.
    

---

# ğŸ  Ğ”Ğ¾Ğ¼Ğ°ÑˆĞ½ĞµĞµ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ


- LC 62 â€” Unique Paths
- LC 64 â€” Minimum Path Sum
- LC 1143 â€” Longest Common Subsequence
- LC 72 â€” Edit Distance
- LC 221 â€” Maximal Square


