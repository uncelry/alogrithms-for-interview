
**Цель:** Объяснить ученику, как можно искать данные за $O(1)$, почему это не магия, а математика, и какие проблемы возникают при реализации (коллизии).

### 1. Введение и Мотивация (10 мин)

- **Проблема:** Вспомните массив (список). Поиск элемента по значению занимает $O(N)$. Если данных миллион, нам нужно миллион сравнений.
    
- **Идея:** Что, если бы мы могли знать _индекс_ элемента, зная только сам элемент? Как в массиве: `arr[5]` мы получаем мгновенно.
    
- **Аналогия:**
    
    - _Библиотека (Линейный поиск):_ Вы идете вдоль полок и ищете книгу по названию. Долго.
        
    - _Гардероб (Хэш-таблица):_ Вы сдаете куртку и получаете номерок. Чтобы забрать куртку, вы не перебираете все вешалки, вы идете сразу к конкретному номерку.
        
- **Ключевое понятие:** Key-Value (Ключ-Значение).
    

### 2. Хэш-функция и Базовая механика (15 мин)

- **Определение:** Функция, которая преобразует входные данные (строку, число, объект) в число (хэш).
    
- **Свойства хорошей хэш-функции:**
    
    1. Детерминированность (для одного и того же входа всегда один выход).
        
    2. Скорость вычисления.
        
    3. Равномерное распределение значений.
        
- **От хэша к индексу (Бакеты):**
    
    - Хэш может быть огромным числом (напр. 2938475), а наш массив (Underlying Array) имеет размер 10.
        
    - **Операция Modulo (%):** `index = hash(key) % array_size`.
        
    - **Термин "Бакет" (Bucket):** Ячейка в массиве, куда попадает элемент.
        
- **Акцент:** Покажите на примере. Пусть массив длиной 5.
    
    - `"apple"` -> хэш 105 -> `105 % 5` -> индекс 0.
        
    - `"banana"` -> хэш 32 -> `32 % 5` -> индекс 2.
        

### 3. Коллизии: Неизбежное зло (10 мин)

- **Проблема:** Что будет, если мы захотим вставить `"cherry"`, у которой хэш 10? `10 % 5` -> индекс 0. Но там уже лежит `"apple"`!
    
- **Определение:** Ситуация, когда два разных ключа претендуют на один и тот же бакет (индекс).
    
- **Парадокс дней рождения (кратко):** Коллизии случаются гораздо чаще, чем нам кажется. Избежать их полностью невозможно.
    

### 4. Разрешение коллизий: Открытая адресация (Open Addressing) (30 мин) — _Основная часть_

Здесь мы отходим от метода цепочек (Linked Lists), так как запрос был именно про открытую адресацию.

- **Концепция:** "Если мое место занято, я найду другое _внутри того же массива_". Никаких дополнительных списков, все хранится в одной плоской структуре.
    
- **Метод 1: Линейное пробирование (Linear Probing)**
    
    - Алгоритм: Если `index` занят, пробуем `index + 1`, потом `index + 2` и так далее по кругу.
        
    - _Проблема кластеризации:_ Если много ключей попадают в соседние ячейки, образуется длинный "кластер", который тормозит поиск.
        
- **Метод 2: Квадратичное пробирование (Quadratic Probing)**
    
    - Алгоритм: Если `index` занят, пробуем `index + 1^2`, `index + 2^2`, `index + 3^2` (то есть +1, +4, +9...).
        
    - _Плюс:_ Уменьшает первичную кластеризацию.
        
- **Метод 3: Двойное хэширование (Double Hashing)**
    
    - Алгоритм: Используем _вторую_ хэш-функцию для определения шага.
        
    - `step = hash2(key)`. Следующий индекс: `(index + step) % size`.
        
    - _Важно:_ Шаг не должен быть 0 и должен быть взаимно прост с размером таблицы.

### 5. Операции: Вставка, Поиск, Удаление (15 мин)

- **Вставка:** Описано выше (хэшируем -> занято? -> пробируем -> вставляем).
    
- **Поиск:** Тот же путь. Хэшируем -> смотрим в ячейку.
    
    - Ключ совпал? Нашли.
        
    - Ячейка пустая? Элемента нет.
        
    - Ключ не совпал (там другой)? Идем дальше по алгоритму пробирования.
        
- **Удаление (Сложный момент!):**
    
    - Нельзя просто очистить ячейку!
        
    - _Пример:_ Были ключи A и B (коллизия, B встал после A). Если удалить A и сделать ячейку пустой, то при поиске B мы наткнемся на пустую ячейку A и подумаем, что B в таблице нет.
        
    - **Решение:** Метка `DELETED` (или "Tombstone" — могильный камень). При поиске мы проскакиваем такие метки, при вставке — можем перезаписать их.

### 6. Сложность и Load Factor (10 мин)

- **Load Factor ($\alpha$):** Отношение числа элементов к размеру массива ($\alpha = N / Size$).
    
- **Ресайзинг:** Когда $\alpha$ достигает порога (обычно 0.7 или 0.75), мы создаем новый массив (x2 больше) и _перехэшируем все элементы_. Это дорогая операция ($O(N)$), но редкая (амортизированная сложность).
    
- **Сложность:**
    
    - Средний случай: $O(1)$.
        
    - Худший случай (все попали в один кластер): $O(N)$.
        

Задачки:
	https://leetcode.com/problems/valid-anagram/description/
	https://leetcode.com/problems/group-anagrams/description/
	https://leetcode.com/problems/two-sum/description/ (через хэш-таблицу)

